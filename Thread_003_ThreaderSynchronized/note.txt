线程同步互斥的问题：

1，线程安全的问题可以用银行转账来解释
	------多个窗口再操作同一个账户时的问题
		
2，使用synchronized(Object lockObject)代码块或者synchronized关键字修饰方法来完成线程同步
	------在多个线程同时操作同一个对方的方法时，为了确保该方法的原子性，
	【即同一时间只能有一个线程对该方法进行操作】，可以使用synchronized(Object lockObject)的方式来修饰方法中的代码。
	其中：参数lockOject是一个同步锁对象，java中任意一个对象都可以作为同步锁对象。
	【必须保证每个线程的同步锁对象都是同一个对象】
	------其实整个过程可以理解为在高铁上上卫生，A君进卫生间(synchronized同步代码块)，锁上卫生间的门(参数lockObject)。
		这时，其他的人是无法实现卫生间的，只有当A君出来，其他人才能进去，
		也不能随便使用其他的锁，比如B君进去后，带了一把自己的锁，把门锁住，这是行不通的。

	【总之synchronized同步方式或者同步代码块，实现了线程之间的互斥】
	【synchronized修饰的同步方法，使用的同步锁对象就是this】
	【静态方法的同步，使用的同步锁对象是.class对象】
	【为了避免同步锁的死锁情况的发生，需要同步的方法最好只出现一次synchronized关键字】
	
3，wait和notify时的注意事项
	------当线程互斥时，调用同步锁对象的wait()方法来将当前线程挂起，调用同步锁对象的notify()方法来唤醒被挂起的线程的其中的一个。
	【wait和notify的方法的调用者必须是同步锁对象，否则会出现假唤醒的情况】
